# Java [0] last update
1. Herança
2. final palavra-chave para uma variavel
3. final palavra-chave para um metodo
4. final palavra-chave para uma classe
5. Declarar, alocar memoria e inicializar um array
6. Outra forma nao usual de declarar array
7. Declarar um array abreviado com inicialização
8. Matriz de mais de uma dimensao com inicialização
9. Concatenar duas string
10. if...else
11. Switch com default
12. while
13. do while
14. for loop
15. for loop aprimorado
16. label e uma break encerrando a label externa
17. continue palavra-chave
18. construtor e encapsulamento
19. declaração simples de um metodo
20. sobrecarga de metodo
21. metodo com um array como parametro
>22. sintaxe spreed
23. Instanciação
24. Referenciar um campo/metodo de objeto
25. Método retornando um tipo de referência
26. Usar this em um construtor para resolver problema de identificadores iguais
27. Construtor usando this para chamar outro construtor
28. Membro static
29. campo static final
30. blocos de inicialização estáticos
31. Blocos inicializadores para variáveis ​​de instância
32. Instaniar diretamente uma classe interna
33. classe local
34. classe local acessando membro final do metodo
35. Variavel efetivamente final
36. Interface sendo usado como variavel tipo de uma classe
37. Classe anonima com interface
38. Usando uma enum
39. expressao lambda
40. corpo de expressão lambda com múltiplas instruções dentro das chaves
41. operador de referência de método
42. enum com 2 valores entre ()
43. atributo deprecated
44. atributo override
45. interface e implements 
46. interface extends outra interface
47. interface com default modificador
48. interface com membro static
49. interface com constantes
50. uso de .super. para resolver conflito em interface
51. uso de super() em classe
52. importação estática
53. definir uma string
54. concatenar uma string com tambem uma variavel
55. Classe com construtor, campo, metodo e o metodo main
56. Uso package e import
57. Inferir o tipo da variavel com var palavra chave
58. Campo static final
59. Interface com metodo default
60. Classe anonima estendendo de uma classe concreta

# Javascript [2] last update 19/11
1. Definir uma função com uma expressão de função condicionalmente
2. Criar uma função com 'function' construtor
3. Arrow 'function' sem e com abreviações
4. Callback
5. Cadeia de promise com arrow function
6. Chamar uma função
7. closure
8. Expressão de função
9. Função anônima como argumento de outra função
10. Função auto invocada com e sem argumento
11. Função auto invocado com void
12. Função com um iterator e consumir ele
13. Função construtora com campo e metodo
14. Função hoisting
15. Funções de seta
16. Função geradora lidando com sequencias assincrona
17. Lançar uma exeção com um bloco de instrução
18. Acessando um objeto, criando e atribuindo valores as propriedades
19. Matriz de 2 dimensoes sendo criada e acessada
20. Uso arguments
21. Classe com construtor e um metodo, sendo construido com tres campos direto no construtor
22. Classe com campos e metodos privados
23. try...catch
24. concatenar string com +
25. Uso de get/set com propriedades privadas em classe
26. Uso while
27. Uso throw
28. Uso var, let e const
29. tratamento de erro async/await
30. usar async/await
31. template string
32. typeof
33. for...of
34. switch
35. super e this em classes
36. for..in
37. Herança em classe e override metodos da classe pai
38. do while
39. campos static, metodo static e static block em uma class
40. parametro rest em contrutor de classe
41. objeto literal
42. parametro padrão
43. use de then em promisse, com suas duas funções no Promise construtor
44. declaração de função
45. definir campo/metodo em prototype
46. definir um get/set em um objeto literal
47. definir um get/set posteriomente em um objeto ja criado
48. definir um metodo em uma classe via this
49. definir um metodo normal e abreviado em um objeto literal
50. destruturação em for..of
51. substituir um membros static de uma classe, mas aprimorado com super
52. Objeto literal com prototipo, campo e metodo
53. Definir dinamicamente o nome de um campo em um objeto literal
54. Definir dinamicamente o nome de um campo em uma classe

# Typescript [0] last update
> 1.1 adicionando novos campos a uma interface existente com interface
> 1.2 adicionando novos campos a uma interface existente com type
> 1.3 alias de tipo para nomear um tipo de função
> 1.4 alias para um tipo união e depois usar o alias na função
1.5 aliases de tipo para tipos, objeto e função
1.6 alias de anotação Tipos de objeto em funções
1.7 anotações de Tipo de Retorno
1.8 anotações de tipo em variáveis
1.9 as duas formas de declarar matrizes
2.1 asserções de tipo com as do menos especifico para o mais especifico
2.2 asserções de tipo com as
2.3 asserções de tipo com <>
2.4 assinatura de construção
2.5 assinatura de construção e de metodo
2.6 assinatura de indice em classes
2.7 tipo de objeto com uma assinatura de índice
2.8 Campo reandoly em classe
2.9 Variavel readonly
3.1 classe com membro private
3.2 classe com membro protected
3.3 classe com membro public
3.4 classe e membros abstract
3.5 classe função com uma assinatura de construção, no caso, implements em uma interface com uma
3.6 classe membros static com modificadores de acesso
3.7 classes genericas sem construtor
3.8 classes genericas com construtor
3.9 combinação de uma função com uma propriedade associada em um tipo, que pode ser usado como parâmetro em uma função normal
4.1 tsc

4.2 construtor com campos publicos diretamente inserido
4.3 declarar uma classe com campos, construtor e metodos
4.4 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por uma classe
4.5 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por um objeto literal
4.6 definindo um tipo de união em uma função
4.7 desestruturar tuplas, const com tipo tupla
4.8 desestruturar tupla como parametro de uma função
4.9 função com desestruturação de parâmetros
5.1 Enums
5.2 especificar o argumento passado para a função génerica
5.3 estendendo e tambem implementando uma interface
5.4 estendendo um tipo por meio de interseções
5.5 estreitamento em tipos de união
5.6 declare o tipo this no corpo da função
5.7 extends em classe
5.8 nao sei
5.9 função Genérica
6.1 funções Genéricas com varios parameotros
6.2 get/set em classes
6.3 implements em classes
6.4 inferencia explicita ao chamar uma função génerica
6.5 interface
6.6 interface com um tipo generico
6.7 membros normais e uma assinatura de indice para caso eu precise mais propriedades extra
6.8 metodos em classes com tipagem em todos os tipos diferentes de membros possiveis
6.9 operador de Asserção Não Nulo (Postfix !)
7.1 overloads em construtores de classe
7.2 parametro de funções opcionais com ? e valor padrão
7.3 parametro rest em função

7.4 parâmetros opcionais em retornos de chamada/calback
7.5 Anotação de tipo explicito de uma função como parametro de uma função