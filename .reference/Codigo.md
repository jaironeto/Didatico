# Java [0] last update
> 1.1 Herança
> 1.2 final palavra-chave para uma variavel
> 1.3 final palavra-chave para um metodo
> 1.4 final palavra-chave para uma classe
> 1.5 Declarar, alocar memoria e inicializar um array
> 1.6 Outra forma nao usual de declarar array
> 1.7 Declarar um array abreviado com inicialização
> 1.8 Matriz de mais de uma dimensao com inicialização
> 1.9 Concatenar duas string
> 2.1 if...else
> 2.2 Switch com default
> 2.3 while
> 2.4 do while
> 2.5 for loop
> 2.6 for loop aprimorado
> 2.7 label e uma break encerrando a label externa
> 2.8 continue palavra-chave
> 2.9 construtor e encapsulamento
> 3.1 declaração simples de um metodo
> 3.2 sobrecarga de metodo
> 3.3 metodo com um array como parametro
> 3.4 sintaxe spreed
> 3.5 Instanciação
> 3.6 Referenciar um campo/metodo de objeto
> 3.7 Método retornando um tipo de referência
> 3.8 Usar this em um construtor para resolver problema de identificadores iguais
> 3.9 Construtor usando this para chamar outro construtor
> 4.1 Membro static
> 4.2 campo static final
> 4.3 blocos de inicialização estáticos
> 4.4 Blocos inicializadores para variáveis ​​de instância
< 4.5 Instaniar diretamente uma classe interna
< 4.6 classe local
< 4.7 classe local acessando membro final do metodo
< 4.8 Variavel efetivamente final
< 4.9 Interface sendo usado como variavel tipo de uma classe
< 5.1 Classe anonima com interface
> 5.2 Usando uma enum
< 5.3 expressao lambda
< 5.4 corpo de expressão lambda com múltiplas instruções dentro das chaves
5.5 operador de referência de método
5.6 enum com 2 valores entre ()
5.7 atributo deprecated
5.8 atributo override
5.9 interface e implements 
6.1 interface extends outra interface
6.2 interface com default modificador
6.3 interface com membro static
6.4 interface com constantes
6.5 uso de .super. para resolver conflito em interface
6.6 uso de super() em classe
6.7 importação estática
6.8 definir uma string
6.9 concatenar uma string com tambem uma variavel
7.1 Classe com construtor, campo, metodo e o metodo main
7.2 Uso package e import
7.3 Inferir o tipo da variavel com var palavra chave
7.4 Campo static final
7.5 Interface com metodo default
7.6 Classe anonima estendendo de uma classe concreta

# Javascript [1] last update 19:06
1.1 Definir uma função com uma expressão de função condicionalmente
1.2 Criar uma função com 'function' construtor
1.3 Arrow 'function' sem e com abreviações
1.4 Callback
1.5 Cadeia de promise com arrow function
1.6 Chamar uma função
1.7 closure
1.8 Expressão de função
1.9 Função anônima como argumento de outra função
2.1 Função auto invocada com e sem argumento
2.2 Função auto invocado com void
2.3 Função com um iterator e consumir ele
2.4 Função construtora com campo e metodo
2.5 Função hoisting
2.6 Funções de seta
2.7 Função geradora lidando com sequencias assincrona
2.8 Lançar uma exeção com um bloco de instrução
>2.9 Acessando um objeto, criando e atribuindo valores as propriedades
3.1 Matriz de 2 dimensoes sendo criada e acessada
3.2 Uso arguments
3.3 Classe com construtor e um metodo, sendo construido com tres campos direto no construtor
3.4 Classe com campos e metodos privados
3.5 try...catch
3.6 concatenar string com +
3.7 Uso de get/set com propriedades privadas em classe
3.8 Uso while
3.9 Uso throw
4.1 Uso var, let e const
4.2 tratamento de erro async/await
4.3 usar async/await
4.4 template string
4.5 typeof
4.6 for...of
4.7 switch
4.8 super e this em classes
4.9 for..in
5.1 Herança em classe e override metodos da classe pai

5.2 do while
5.3 campos static, metodo static e static block em uma class
5.4 parametro rest em contrutor de classe
5.5 objeto literal
5.6 parametro padrão
5.7 use de then em promisse, com suas duas funções no Promise construtor
5.8 declaração de função
5.9 definir campo/metodo em prototype
6.1 definir um get/set em um objeto literal
6.2 definir um get/set posteriomente em um objeto ja criado
6.3 definir um metodo em uma classe via this
6.4 definir um metodo normal e abreviado em um objeto literal
6.5 destruturação em for..of
6.6 substituir um membros static de uma classe, mas aprimorado com super
6.7 Objeto literal com prototipo, campo e metodo
6.8 Definir dinamicamente o nome de um campo em um objeto literal
6.9 Definir dinamicamente o nome de um campo em uma classe

# Typescript [0] last update
> 1.1 adicionando novos campos a uma interface existente com interface
> 1.2 adicionando novos campos a uma interface existente com type
> 1.3 alias de tipo para nomear um tipo de função
> 1.4 alias para um tipo união e depois usar o alias na função
1.5 aliases de tipo para tipos, objeto e função
1.6 alias de anotação Tipos de objeto em funções
1.7 anotações de Tipo de Retorno
1.8 anotações de tipo em variáveis
1.9 as duas formas de declarar matrizes
2.1 asserções de tipo com as do menos especifico para o mais especifico
2.2 asserções de tipo com as
2.3 asserções de tipo com <>
2.4 assinatura de construção
2.5 assinatura de construção e de metodo
2.6 assinatura de indice em classes
2.7 tipo de objeto com uma assinatura de índice
2.8 Campo reandoly em classe
2.9 Variavel readonly
3.1 classe com membro private
3.2 classe com membro protected
3.3 classe com membro public
3.4 classe e membros abstract
3.5 classe função com uma assinatura de construção, no caso, implements em uma interface com uma
3.6 classe membros static com modificadores de acesso
3.7 classes genericas sem construtor
3.8 classes genericas com construtor
3.9 combinação de uma função com uma propriedade associada em um tipo, que pode ser usado como parâmetro em uma função normal
4.1 tsc

4.2 construtor com campos publicos diretamente inserido
4.3 declarar uma classe com campos, construtor e metodos
4.4 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por uma classe
4.5 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por um objeto literal
4.6 definindo um tipo de união em uma função
4.7 desestruturar tuplas, const com tipo tupla
4.8 desestruturar tupla como parametro de uma função
4.9 função com desestruturação de parâmetros
5.1 Enums
5.2 especificar o argumento passado para a função génerica
5.3 estendendo e tambem implementando uma interface
5.4 estendendo um tipo por meio de interseções
5.5 estreitamento em tipos de união
5.6 declare o tipo this no corpo da função
5.7 extends em classe
5.8 nao sei
5.9 função Genérica
6.1 funções Genéricas com varios parameotros
6.2 get/set em classes
6.3 implements em classes
6.4 inferencia explicita ao chamar uma função génerica
6.5 interface
6.6 interface com um tipo generico
6.7 membros normais e uma assinatura de indice para caso eu precise mais propriedades extra
6.8 metodos em classes com tipagem em todos os tipos diferentes de membros possiveis
6.9 operador de Asserção Não Nulo (Postfix !)
7.1 overloads em construtores de classe
7.2 parametro de funções opcionais com ? e valor padrão
7.3 parametro rest em função

7.4 parâmetros opcionais em retornos de chamada/calback
7.5 Anotação de tipo explicito de uma função como parametro de uma função