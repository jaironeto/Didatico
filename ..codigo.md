# Java 6/02
1. Herança
2. final palavra-chave para uma variavel
3. final palavra-chave para um metodo
4. final palavra-chave para uma classe
5. Declarar, alocar memoria e inicializar um array
6. Outra forma nao usual de declarar array
7. Declarar um array abreviado com inicialização
8. Matriz de mais de uma dimensao com inicialização
9. Concatenar duas string
10. if...else
11. Switch com default
12. while
13. do while
14. for loop
15. for loop aprimorado
16. label e uma break encerrando a label externa
17. continue palavra-chave
18. construtor e encapsulamento
19. declaração simples de um metodo
20. sobrecarga de metodo
21. metodo com um array como parametro
22. sintaxe spreed
23. Instanciação
24. Referenciar um campo/metodo de objeto
25. Método retornando um tipo de referência
26. Usar this em um construtor para resolver problema de identificadores iguais
27. Construtor usando this para chamar outro construtor
28. Membro static
29. campo static final
30. blocos de inicialização estáticos
31. Blocos inicializadores para variáveis ​​de instância
32. Instaniar diretamente uma classe interna
33. classe local
34. classe local acessando membro final do metodo
35. Variavel efetivamente final
36. Interface sendo usado como variavel tipo de uma classe
37. Classe anonima com interface
38. Usando uma enum
39. expressao lambda
40. corpo de expressão lambda com múltiplas instruções dentro das chaves
41. operador de referência de método
42. enum com 2 valores entre ()
43. atributo deprecated
44. atributo override
45. interface e implements 
46. interface extends outra interface
47. interface com default modificador
48. interface com membro static
49. interface com constantes
50. uso de .super. para resolver conflito em interface
51. uso de super() em classe
52. importação estática
53. definir uma string
54. concatenar uma string com tambem uma variavel
55. Classe com construtor, campo, metodo e o metodo main
56. Uso package
57. Inferir o tipo da variavel com var palavra chave
58. Campo static final
59. Interface com metodo default
60. Classe anonima estendendo de uma classe concreta
61. rule switch
62. uso import
63. classe abstract

# Javascript 5/02
1. Definir uma função com uma expressão de função condicionalmente
2. Criar uma função com 'function' construtor
3. Arrow 'function' sem e com abreviações
4. Callback
5. Cadeia de promise com arrow function
6. Chamar uma função
7. closure
8. Expressão de função
9. Função anônima como argumento de outra função
10. Função auto invocada com e sem argumento
11. Função auto invocado com void
12. Função com um iterator e consumir ele
13. Função construtora com campo e metodo
14. Função hoisting
15. Funções de seta
16. Função geradora lidando com sequencias assincrona
17. Lançar uma exeção com um bloco de instrução
18. Acessando um objeto, criando e atribuindo valores as propriedades
19. Matriz de 2 dimensoes sendo com inicialiazação sendo criada e acessada
20. Uso arguments
21. Classe com construtor e um metodo, sendo construido com tres campos direto no construtor
22. Classe com campos e metodos privados
23. try...catch
24. concatenar string com +
25. Uso de get/set com propriedades privadas em classe
26. Uso while
27. Uso throw
28. Uso var, let e const
29. tratamento de erro async/await
30. usar async/await
31. template string
32. typeof
33. for...of
34. switch
35. super e this em classes
36. for..in
37. Herança em classe e override metodos da classe pai
38. do while
39. campos static, metodo static e static block em uma class
40. parametro rest em contrutor de classe
41. objeto literal
42. parametro padrão
43. use de then em promisse, com suas duas funções no Promise construtor
44. declaração de função
45. definir campo/metodo em prototype
46. definir um get/set em um objeto literal
47. definir um get/set posteriomente em um objeto ja criado
48. definir um metodo em uma classe via this
49. definir um metodo normal e abreviado em um objeto literal
50. destruturação em for..of
51. substituir um membros static de uma classe, mas aprimorado com super
52. Objeto literal com prototipo, campo e metodo
53. Definir dinamicamente o nome de um campo em um objeto literal
54. Definir dinamicamente o nome de um campo em uma classe
55. Export default e import
56. Export nomeado e import
57. Exportando todas as funções como um objeto padrão e import
58. Module.exports e require
59. Module.exports e require com desestruturação

# C# 6/02
1. Main declarado async
2. Instruição de nivel superior
3. Enum
4. Diretiva using em ação eliminando o uso de System no codigo
5. Namespace com chaves
6. Namespace global
7. Propriedade auto-implementada com required e inicializador de objeto
8. Classe com construtor primario
9. Uso simples de record
10. Uso record com with
11. Uso record mais complicadinho
12. Tipo anonimo
13. Tipo anonimo com um membro mais complexo
14. Matriz com tipo anonimo
15. Mutação com with em tipo anonimo
16. Criando uma struct com new e tambem a partir de um objeto struct ja criado sem usar new
17. Override em metodo virtual
18. Ocultar membro com new
19. Membro ocultado com new sendo convertido para chamar o metodo da classe base que foi ocultado
20. Polimorfismo e selead
21. Usando base palavra chave
22. Usando tupla +1 forma
23. Desconstruindo tupla
24. Desconstruindo tupla com Desconstruct metodo
25. Override metodo toString() object
26. Classe e metodo abstract
27. Classe abstract transformando um metodo virtual em abstract
28. Acabando com a herança virtual de metodo com selead
29. Classe e metodo selead
30. Criar e acessar uma constante
31. Classe abstract
32. Class constante
33. Campo static reandoly
34. Propriedade
35. Sintaxe simples para propriedade somente leitura com membro apto de expressao
36. Propriedade com membro apto de expressao
37. Propriedade auto-implementada
38. Propriedade auto-implementada required
39. Propriedade em interface
40. Acessador propriedade com modificador de acesso
41. Inicializar propriedade auto-implementada
42. Retornar valor por ref
43. Usar uma ref local
44. Metodo async
45. Metodo de extensao
46. Finalizador
47. Um namespace dentro aninhado em outro namespace
48. Main async return
49. Record simples
50. Record com propriedade required
51. Codigo simples e basico com uma class, construtor e propriedades
52. Uso do modificador new em metodos nao virtuais
53. Substituir metodo toString()
54. Abstract herdando de uma classe e transformando um metodo virtual em abstract, para depois quem herdar do metodo abstract dar override
55. switch
56. Campo, propriedade e metodo static
57. Campos const
58. Classe base abstract com propriedade abstract que entao sera override por classes derivadas
59. Nova implementação com new operador sem o uso de virtual
60. Propriedade com acessibilidade diferente
61. Valor retornado por ref
62. ref recebendo uma ref
63. Metodo de extensao com ref e sem ref
64. Metodo de extensao
65. Metodo de extensao para string
66. Usando enum
67. Argumento nomeado e posicional
68. Construtor simples
69. Construtor com : base
70. Sobrecarga de construtor
71. Construtor com : this
72. Classe abstract com construtor sendo acessado quando derivado
73. Construtor static
74. Finalizador
75. As duas sintaxe de inicializador de objeto
76. Tipo aninhado
X Class partial
X Metodos partial
79. literais de cadeia de caracteres entre aspas
80. Literais de cadeia de caracteres textuais
81. Literais de cadeia de caracteres bruta
82. cadeias de caracteres interpoladas
83. literais de cadeia de caracteres bruta com interpolações de cadeia de caracteres
84. Formatação de composição
85. Delegate simples
86. Adicionar e remover um metodo a um delegate
87. Indexador simples
88. Indexador somente leitura e com parametro generico
89. Indexador em uma interface
90. Campos const em uma classe static
91. implementação de interface explícita
92. Uso params
93. Acessando um membro de uma interface herdada, declarando o tipo da interface e usando a variavel da classe
94. Indexador normal
95. Indexador somente leitura
96. Indexador normal com membro apto de expressao
97. Criando uma excessao com uma classe derivada de exception
98. Varios catch para um exception
99. filtros de exceção para adicionar uma expressão booliana a uma cláusula catch
100. Passando um valor por referencia
X 101. Evento
102. Inicializador de objeto e um construtor ao mesmo tempo
103. Classe generica"
104. Metodo generico
105. Usando operator para sobrescrever o operador + da classe

# React.js
1. Conceito de usar componente dentro de outros
2. html embutido com fragment
3. Exportando e usando o componente importado
4. Criando uma variavel com o style e entao os usando no componente em style prop
5. Renderização condicional operador tenario e &&
6. Renderizando listas
7. Mantendo componente puro
8. Componente com return abreviado e nao abreviado
9. Codigo limpo, declarando os literals em variaveis e so depois nas props com jsx
10. Usando variaveis javascript dentro do JSX e dentro das tag como texto
11. Usando style elemento css diretamente no html JSX
12. Usando children propriedade passada automaticamente
13. Renderizando itens condicionalmente
14. Renderizando itens condicionalmente e retornando null para nao renderizar
15. Renderizando itens condicionalmente, mas colocando JSX diretamente na variavel
16. Mantendo componente puro
> 17. Usando nome da className em arquivo css
18. Definindo style diretamente no react
19. Renderização condicional
20. Renderização condicional
21. Responder a um evento
22. Use status
23. Use status autualizando 2 botoes ao mesmo tempo
24. Exportação e nomeada no mesmo arquivo
25. Respondendo a eventos
26. **** export
27. Atualizando objetos no estado
28. Atualizando matrizes no estado
29. Evento simples
30. Evento simples inline, as duas formas
31. Lendo adereços em manipuladores de eventos
32. Passando manipuladores de eventos como adereços
33. Nomeando adereços do manipulador de eventos
34. Parando a propagação
35. Renderizar

# Typescript.js 
> 1.1 adicionando novos campos a uma interface existente com interface
> 1.2 adicionando novos campos a uma interface existente com type
> 1.3 alias de tipo para nomear um tipo de função
> 1.4 alias para um tipo união e depois usar o alias na função
1.5 aliases de tipo para tipos, objeto e função
1.6 alias de anotação Tipos de objeto em funções
1.7 anotações de Tipo de Retorno
1.8 anotações de tipo em variáveis
1.9 as duas formas de declarar matrizes
2.1 asserções de tipo com as do menos especifico para o mais especifico
2.2 asserções de tipo com as
2.3 asserções de tipo com <>
2.4 assinatura de construção
2.5 assinatura de construção e de metodo
2.6 assinatura de indice em classes
2.7 tipo de objeto com uma assinatura de índice
2.8 Campo reandoly em classe
2.9 Variavel readonly
3.1 classe com membro private
3.2 classe com membro protected
3.3 classe com membro public
3.4 classe e membros abstract
3.5 classe função com uma assinatura de construção, no caso, implements em uma interface com uma
3.6 classe membros static com modificadores de acesso
3.7 classes genericas sem construtor
3.8 classes genericas com construtor
3.9 combinação de uma função com uma propriedade associada em um tipo, que pode ser usado como parâmetro em uma função normal
4.1 tsc

4.2 construtor com campos publicos diretamente inserido
4.3 declarar uma classe com campos, construtor e metodos
4.4 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por uma classe
4.5 declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por um objeto literal
4.6 definindo um tipo de união em uma função
4.7 desestruturar tuplas, const com tipo tupla
4.8 desestruturar tupla como parametro de uma função
4.9 função com desestruturação de parâmetros
5.1 Enums
5.2 especificar o argumento passado para a função génerica
5.3 estendendo e tambem implementando uma interface
5.4 estendendo um tipo por meio de interseções
5.5 estreitamento em tipos de união
5.6 declare o tipo this no corpo da função
5.7 extends em classe
5.8 nao sei
5.9 função Genérica
6.1 funções Genéricas com varios parameotros
6.2 get/set em classes
6.3 implements em classes
6.4 inferencia explicita ao chamar uma função génerica
6.5 interface
6.6 interface com um tipo generico
6.7 membros normais e uma assinatura de indice para caso eu precise mais propriedades extra
6.8 metodos em classes com tipagem em todos os tipos diferentes de membros possiveis
6.9 operador de Asserção Não Nulo (Postfix !)
7.1 overloads em construtores de classe
7.2 parametro de funções opcionais com ? e valor padrão
7.3 parametro rest em função

7.4 parâmetros opcionais em retornos de chamada/calback
7.5 Anotação de tipo explicito de uma função como parametro de uma função

# Express.js

# Sequelize.js

# SQL

# Git 

# [Library] CSS
# [Library] HTML
# [Library] Javascript

# [Example] CSS